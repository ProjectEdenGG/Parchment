From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Lexi <lexi@qixils.dev>
Date: Thu, 23 Jun 2022 14:41:24 -0400
Subject: [PATCH] Add HangingFrame Tick API


diff --git a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
index 25f5c7346f06bcb58cdaaee2a61b0154761925df..dfc29d0f7a5c7f10588438f4b1d3b00b003a7974 100644
--- a/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/decoration/HangingEntity.java
@@ -20,7 +20,11 @@ import org.apache.commons.lang3.Validate;
 
 public abstract class HangingEntity extends BlockAttachedEntity {
     protected static final Predicate<Entity> HANGING_ENTITY = entity -> entity instanceof HangingEntity;
+
+    private int checkInterval; { this.checkInterval = this.getId() % this.level().spigotConfig.hangingTickFrequency; } // Paper - Perf: offset item frame ticking
+    public BlockPos pos;
     protected Direction direction = Direction.SOUTH;
+    public boolean tick = true; // Parchment
 
     protected HangingEntity(EntityType<? extends HangingEntity> type, Level world) {
         super(type, world);
@@ -53,6 +57,38 @@ public abstract class HangingEntity extends BlockAttachedEntity {
     protected abstract AABB calculateBoundingBox(BlockPos pos, Direction side);
 
     @Override
+    public void tick() {
+        if (tick && !this.level().isClientSide) { // Parchment
+            this.checkBelowWorld();
+            if (this.checkInterval++ == this.level().spigotConfig.hangingTickFrequency) { // Spigot
+                this.checkInterval = 0;
+                if (!this.isRemoved() && !this.survives()) {
+                    // CraftBukkit start - fire break events
+                    BlockState material = this.level().getBlockState(this.blockPosition());
+                    org.bukkit.event.hanging.HangingBreakEvent.RemoveCause cause;
+
+                    if (!material.isAir()) {
+                        // TODO: This feels insufficient to catch 100% of suffocation cases
+                        cause = org.bukkit.event.hanging.HangingBreakEvent.RemoveCause.OBSTRUCTION;
+                    } else {
+                        cause = org.bukkit.event.hanging.HangingBreakEvent.RemoveCause.PHYSICS;
+                    }
+
+                    org.bukkit.event.hanging.HangingBreakEvent event = new org.bukkit.event.hanging.HangingBreakEvent((org.bukkit.entity.Hanging) this.getBukkitEntity(), cause);
+                    this.level().getCraftServer().getPluginManager().callEvent(event);
+
+                    if (this.isRemoved() || event.isCancelled()) {
+                        return;
+                    }
+                    // CraftBukkit end
+                    this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DROP); // CraftBukkit - add Bukkit remove cause
+                    this.dropItem((Entity) null);
+                }
+            }
+        }
+
+    }
+
     public boolean survives() {
         if (!this.level().noCollision(this)) {
             return false;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHanging.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHanging.java
index f1e3f2b89bcd969f3c80548e165881a9b290eb53..f2d46e908ca0030da514a686763e65a57f02cf35 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHanging.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHanging.java
@@ -66,4 +66,16 @@ public class CraftHanging extends CraftBlockAttachedEntity implements Hanging {
     public String toString() {
         return "CraftHanging";
     }
+
+    // Parchment start
+    @Override
+    public boolean canTick() {
+        return this.getHandle().tick;
+    }
+
+    @Override
+    public void setCanTick(boolean tick) {
+        this.getHandle().tick = tick;
+    }
+    // Parchment end
 }
